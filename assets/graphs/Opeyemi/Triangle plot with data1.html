<!DOCTYPE html>
<html>
    <head>
        <title>ICA triangle</title>
        <script src="https://d3js.org/d3.v7.min.js" charset = 'utf-8'></script>
    </head>
    <body>
        <style>
            .tick line {
                stroke: #C0C0BB
            } 
            #div {
                align-items: center;
                display: flex;   
                justify-content: center;
            }           
        </style>
        <div id="div"></div>
        <script>

            d3.json("triangle chart data 1.json").then(triangleplot);


            function triangleplot (data) {

                console.log('Data =', data)

                //Chart Definitions
                const X = 'Sales $'
                const Y = 'Profit $'
                const Z = 'Quantity'
                const title = 'Triangle Plot of Quantity by sub Category'
                const titleSize = 28

                const categories = d3.map(data, function(d){return d['sub Category']})

                console.log('sub Categories = ', categories)


                //dimensions of svg viewport
                const w = 500;
                const h = 500;
                const lmargin = 50; //left magin
                const rmargin = 50; //right margin
                const tmargin = 60; //top margin
                const bmargin = 50; //bottom margin
                const plot_width = w - lmargin - rmargin
                const plot_height = h - tmargin - bmargin
                


                //creating svg viewport variable                
                const svg = d3.select('#div')
                                .append('svg')
                                .attr('width', w)
                                .attr('height', h)
                                //.style('border', 'solid red')
                                .style('background', 'WhiteSmoke');


                //Functions for Formulas for Equilateral Triangle dimensions

                //function to convert degrees to radians
                function d_radians(degrees) {
                    return degrees * Math.PI/180
                }
                //or better yet, maybe just a variable that stores 30 degrees in radians

                //function to derive length from the size(area)
                function length_f (size) {
                    return Math.sqrt((2 * size)/Math.cos(d_radians(30)))
                }

                //function to derive height from the size
                function height_f (size) {
                return Math.sqrt(2 * size * Math.cos(d_radians(30)))
                }

                //making a variable for scale_factor for size of polygon
                const scale = 0.5;
                //maybe instead of using this i use that resize transformation


                //Find the max value among the attendance which is 100
                const maxx = d3.max(data.map(function(d){return (d[X]);}))

                //Find the max value among the attendance which is 100
                const maxy = d3.max(data.map(function(d){return (d[Y]);}))

                //Find the max value among the attendance which is 100
                const maxz = d3.max(data.map(function(d){return (d[Z]);}))

                //
                //const maxx2 = length_f(maxz *1/scale)/2 + maxx
                //const maxx2 = 100000 + maxx

                const maxx2 =  1000000

                const maxy2 = maxz + maxy

                console.log('yMax =', maxy2)

                console.log('xMax =', maxz)




                //Gridlines
                const yScale2 = d3.scaleLinear()
                                    .domain([0, maxy2])
                                    .range([h - bmargin, tmargin]);

                const xScale2 = d3.scaleLinear()
                                    .domain([0, maxx2])
                                    .range([lmargin, w - rmargin]);


                const gridlines = svg.append('g')
                                
                const x_grid = gridlines.append('g').attr('transform', 'translate(0,'+(h - bmargin)+')')

                const y_grid = gridlines.append('g').attr('transform', 'translate('+lmargin+',0)')
                
                const xGridlines = x_grid.call(d3.axisBottom(xScale2).tickSize(-plot_height).ticks(20).tickFormat(''))  

                const yGridlines = y_grid.call(d3.axisLeft(yScale2).tickSize(-plot_width).ticks(20).tickFormat('')) 

                
                //group for plotted data
                const plotArea = svg.append('g')

                //Color Scales
                const colourScale = d3.scaleOrdinal(d3.schemeCategory10);
                                        

                //plot the scatter plot using triangles in the plotarea group
                const graph =
                    plotArea.selectAll('polygon.triangles') 
                    .data(data)
                    .enter()
                    .append('polygon')
                        .attr('class', 'triangles')
                        .attr('points', function(d) {return `${(xScale2(d[X]))}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale)/3))} 
                                                    ${(xScale2(d[X])) - (length_f(d[Z] * scale)/2)}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale)/3)) + (height_f(d[Z] *scale))} 
                                                    ${(xScale2(d[X])) + (length_f(d[Z] * scale)/2)}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale)/3)) + (height_f(d[Z] *scale))}`})

                        .attr('fill', colourScale)
                        .attr('opacity', 0.5)
                        .attr('stroke', 'black')
        
                        
                //Definitions for Function To animate triangles
                const interpol_rotate = d3.interpolateString( "rotate(0)", "rotate(360)" )

                ///create a function for clockwise rotation
                function rotateCW (x, y) {
                    return d3.interpolateString('rotate(0,'+x+','+y+')', 'rotate(360,'+x+','+y+')')
                }

                ///create another function Anti clockwise rotation
                function rotateACW (x, y) {
                    return d3.interpolateString('rotate(0,'+x+','+y+')', 'rotate(-360,'+x+','+y+')')
                }
                       
                //The Animation Function
                function animateTriangle(item){
                    plotArea
                        .selectAll(item)
                        .transition()
                        .duration(2500)
                        .attrTween('transform' , function(d,i,a){ return rotateCW(xScale2(d[X]), yScale2(d[Y]))} )   

                        /*.transition() //And rotate back again
                        .duration(2500)
                        .attrTween('transform' , function(d,i,a){ return rotateACW((d[X] * scalex + rmargin), (h - (d[Y] * scaley) - bmargin))} )
                         */                       
                        }
                                        
                //Call the animateTriangle function om the class 'triangles'
                animateTriangle('.triangles')

                

                //Signify the center with circles
                plotArea.selectAll('circle')
                    .data(data)
                    .enter()
                    .append('circle')
                        .attr('cx', function(d){return (xScale2(d[X]));})
                        .attr('cy', function(d){return (yScale2(d[Y]));})
                        .attr('r', 3) // choose a minimal values for radius of circles
                        .attr('fill', 'black'); //can choose color of choice

                
                //THE AXES

                //Y-AXIS

                //Find the max value for y
                const maxY = d3.max(data.map(function(d){return (d[Y]);}))

                //Set up a linear scale from 0 to max
                const yScale = d3.scaleLinear()
                                    .domain([0, maxy2])
                                    .range([h - bmargin, tmargin]); 


                //Choose a left axis type for our y-axis, because it will be on the left
                const yAxis = d3.axisLeft(yScale)
                                    

                //create a group for our y-axis
                const yAxisGroup = svg.append('g')
                                        .attr('transform', `translate(${lmargin}, ${0})`)
                                        .call(yAxis);  //call the y-axis type with the yscale created
            
                //Add a title to the y-axis
                yAxisGroup.append('text')
                            .text(Y)
                            .attr('y', plot_height/2 - bmargin)
                            .attr('x', lmargin/2) //set in the middle of left margin
                            .attr('transform', 'translate(-225, 225) rotate(270)') //added by me
                            .style('fill', 'black')
                            .attr('font-size', 14)
                            .attr('text-anchor', 'middle');


                //X-AXIS

                //Find the max value for x
                const maxX = d3.max(data.map(function(d){return (d[X]);}))

                //Set up a linear scale from 0 to max
                const xScale = d3.scaleLinear()
                                    .domain([0, maxx2])
                                    .range([lmargin, w - rmargin]);

                                
                

                //Choose a bottom axis type for our x-axis, cause the x-axis is needed on the bottom
                const xAxis = d3.axisBottom(xScale)
                               

                //create a group for our x-axis
                const xAxisGroup = svg.append('g')
                                        .attr('transform', `translate(${0}, ${h - bmargin})`)
                                        .call(xAxis); //call the x-axis created with xScale


                //Add a title to the x-axis
                xAxisGroup.append('text')
                            .text(X)
                            .attr('y', bmargin/2 + 10) 
                            .attr('x', plot_width/2 + lmargin)
                            .style('fill', 'black')
                            .attr('font-size', 14)
                            .attr('text-anchor', 'middle');

                //labels for category
                plotArea.selectAll('text')
                            .data(data)
                            .enter()
                            .append('text')
                                .text(function(d){return d['sub Category']})
                                .attr('x', function(d){return (xScale2(d[X]));})
                                .attr('y', function(d){return yScale2(d[Y]) + height_f(d[Z] * scale)/3 + 12;})
                                .style('fill', 'black')
                                .attr('font-size', 14)
                                .attr('text-anchor', 'middle'); 
                 
                                
                //adding title to chart with svg text
                plotArea.append('text')
                .attr('y', 45)
                .attr('x', plot_width/2 + lmargin)
                .text(title)
                .attr('font-family', 'sans-serif')
                .attr('font-size', titleSize)
                .attr('text-anchor', 'middle');


            // ADDING SOME BASIC INTERACTION
            const scale_by = 1.2
            graph
            .on(
                'mouseenter',
                function(event) {
                    const thisPath = d3.select(this);
                    thisPath.style("opacity", 1);
                    thisPath.attr('points', function(d) {return `${(xScale2(d[X]))}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale * scale_by)/3))} 
                                    ${(xScale2(d[X])) - (length_f(d[Z] * scale * scale_by)/2)}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale * scale_by)/3)) + (height_f(d[Z] *scale * scale_by))} 
                                     ${(xScale2(d[X])) + (length_f(d[Z] * scale * scale_by)/2)}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale * scale_by)/3)) + (height_f(d[Z] *scale * scale_by))}`})
                    //thisPath.raise();
                    thisPath.attr('id', 'rotate')
                    animateTriangle('#rotate');
            
                }
            )
            .on(
                "mouseleave",
                function(event) {
                    const thisPath = d3.select(this);
                    thisPath.attr('id', 'donotrotate')
                    thisPath.attr('points', function(d) {return `${(xScale2(d[X]))}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale)/3))} 
                                    ${(xScale2(d[X])) - (length_f(d[Z] * scale)/2)}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale)/3)) + (height_f(d[Z] *scale))} 
                                    ${(xScale2(d[X])) + (length_f(d[Z] * scale)/2)}, ${((yScale2(d[Y])) - (2 * height_f(d[Z] *scale)/3)) + (height_f(d[Z] *scale))}`})
                    thisPath.style("opacity", 0.5);                

            })

        }

        

            
        </script>
    </body>
</html>